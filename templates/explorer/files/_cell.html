<li id="{{ (task_topic ~ '_stream_' ~ stream ~ '_step') }}_{{ task_index }}" step="{{ task_index }}"
    class="row bg-white text-dark clarama-cell-item"
    steptype="{{ task_step['type'] }}"
>
    <div class="panel col-2 col-lg-1 d-flex flex-column justify-content-between
                 {% if task_last %}
                    bg-primary
                 {% else %}
                    bg-secondary
                 {% endif %}
                 text-light draggable-heading justify-content-end position-relative"
         style="padding:0">
        <hr class="faded"/>
        <div class="container-fluid">
            <div class="row">
                <div class="col-auto">
                    <button type="button" class="btn text-white step-label">{{ task_index }}</button>
                </div>
                <div class="col">
                    <input type="text" id="loop-iterable-{{ task_index }}"
                           loop-id="{{ task_index }}"
                           class="form-control loop-iterable loop-inactive"
                           value="{%- if step is defined -%}{{ step['loop-iterable'] }}{%- endif -%}"
                           opacity="0.04">
                </div>
            </div>
            {% if task_step['type'] != "markdown" %}
                <div class="row">
                    <div class="col">&nbsp;</div>
                    <div class="col-auto pb-3"
                         id="task_toolbar_{{ stream }}_{{ task_index }}_play"
                         opacity="0.04">
                        <button type="button" class="btn celleditrun" data-bs-toggle="tooltip"
                                data-bs-placement="bottom" title="Run this step (Ctrl-enter)">
                                <i class="mb-3 fs-4 bi bi-play-fill " style="width: 75px;"></i>
                        </button>
                        {% if task_step['type'] != "data" %}
                        <button type="button" class="btn celleditdebug" data-bs-toggle="tooltip"
                                data-bs-placement="bottom" title="Debug (Ctrl-\)"
                                data-task-index="{{ task_index }}">
                                <i class="mb-3 fs-4 bi bi-bug-fill"></i>
                        </button>
                        {% endif %}
                    </div>
                </div>
            {% endif %}
        </div>

        <div class="cell-spin" style="opacity: 0">
            <div
                    class="d-flex justify-content-center spinner-border text-info position-absolute start-50"
                    role="status"
                    style="width: 4rem; height: 4rem;"
            >
            </div>
        </div>
        <div class="cell-timing container-fluid">
        </div>
    </div>
    <div class="col-10 col-lg-11" style="padding:0px;">
        <div class="container-fluid">
            <div class="row flex-nowrap align-items-center" style="padding:0px;">
                {% include theme("explorer/files/_cell_insert.html") %}
                <div class="col-auto hoverover auto-hover"
                     id="task_toolbar_{{ stream }}_{{ task_index }}_trash"
                     opacity="0.04"
                     style="opacity: 0.04">
                    <button type="button" class="btn delete_step" data-bs-toggle="tooltip"
                            data-bs-placement="bottom" title="Delete this step"><i
                            class="fs-2 bi bi-trash"></i>
                    </button>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="loop loop-edge loop-hidden loop-{{ task_index }}">&nbsp;</div>
            <div class="row">
                <div class="col loop-left loop-hidden loop-{{ task_index }}">
                    <div class="loop loop-left loop-height">&nbsp;</div>
                </div>
                <!-- Left Half -->
                <div class="col-6 left-content" id="left_content_{{ task_index }}">
                    <!-- the Editing -->
                    <div id="step_{{ stream }}_{{ task_index }}"
                         class="clarama-post-embedded cell-editor"
                         post_json="json_{{ task_index }}"
                         url="{{ call('clarama_content.content_template_render','explorer/steps/' ~ task_step['type'] ~ '_edit') }}?loop_index={{ task_index }}">
                    </div>
                    <!-- the Results -->
                    <div class="container-fluid cell-response">
                        <div id="results_{{ task_index }}" class="cell-results"
                             {% if task_step['type'] == "data" %}style="min-height: 50px;" {% endif %}>
                        </div>
                    </div>
                </div>
                <!-- Right Half -->
                <div class="col-6 right-content d-none" id="right_content_{{ task_index }}">
                    {% include theme("explorer/files/_cell_debugger.html") %}
                </div>
            </div>
            <div class="loop loop-edge loop-hidden loop-{{ task_index }}">&nbsp;</div>
        </div>
        <div class="pb-1">&nbsp;</div>
    </div>
</li>

<script>
    function toggle_loop(elem) {
        var val = (elem.val()).trim();

        loop_id = elem.attr('loop-id');

        //console.log("LOOP" + elem.attr('id'));

        //console.log('LOOP .loop-' + loop_id + ' : ' + val);

        //console.log($('.loop-' + loop_id));

        if (val == '') {
            elem.addClass('loop-inactive');
            elem.removeClass('loop-active');
            $('.loop-' + loop_id).addClass("loop-hidden");
            $('.loop-' + loop_id).removeClass("loop-show");
        } else {
            elem.addClass('loop-active');
            elem.removeClass('loop-inactive');
            $('.loop-' + loop_id).removeClass("loop-hidden");
            $('.loop-' + loop_id).addClass("loop-show");
        }
    }

    // Enhanced cell copy/paste functionality with proper content handling
    $(document).ready(() => {
        $('.loop-iterable').each(function () {
            toggle_loop($(this));
        });

        $('.loop-iterable').bind('keypress keydown keyup', function (e) {
            if (e.keyCode == 13) {
                e.preventDefault();
            }
            toggle_loop($(this));
        });

        $("input").off("change");
        $("input").on("change", function () {
            toggle_loop($(this));
        });

        // Hide both context menus initially
        $('#panel-context-menu').hide();
        $('#output-context-menu').hide();

        // Variable to store the current cell results element that was right-clicked
        let currentCellResults = null;
        
        // Right-click event on cell results - target the actual results div (output area)
        $('[id^="results_"]').on('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            currentCellResults = $(this);
            $('#panel-context-menu').hide();
            
            let mouseX = e.clientX;
            let mouseY = e.clientY;
            
            const $contextMenu = $('#output-context-menu');
            
            $contextMenu.css({
                display: 'block',
                position: 'fixed', 
                left: mouseX + 'px',
                top: mouseY + 'px',
                zIndex: 1000
            });
            
            return false;
        });
        
        // Right-click event on panel (editor area)
        $('.panel').on('contextmenu', function(e) {
            e.preventDefault();
            e.stopPropagation(); 

            currentContextCell = $(this).closest('.clarama-cell-item');
            $('#output-context-menu').hide();
            
            let mouseX = e.clientX;
            let mouseY = e.clientY;
            
            const $contextMenu = $('#panel-context-menu');
            
            $contextMenu.css({
                display: 'block',
                position: 'fixed', 
                left: mouseX + 'px',
                top: mouseY + 'px',
                zIndex: 1000
            });
            
            return false;
        });
        
        // Hide context menus when clicking elsewhere
        $(document).on('click', function(e) {
            if (!$(e.target).closest('#panel-context-menu, #output-context-menu').length) {
                $('#panel-context-menu').hide();
                $('#output-context-menu').hide();
            }
        });

        $(document).on('contextmenu', function(e) {
            if (!$(e.target).closest('.panel, .cell-editor, [id^="results_"]').length) {
                $('#panel-context-menu').hide();
                $('#output-context-menu').hide();
            }
        });
        
        $(window).on('scroll', function() {
            $('#panel-context-menu').hide();
            $('#output-context-menu').hide();
        });

        function extractCellContent(cell) {
            const cellType = cell.attr('steptype');
            const taskIndex = cell.attr('step');
            let content = {};
            
            console.log('Extracting content for cell type:', cellType, 'task index:', taskIndex);
            
            switch(cellType) {
                case 'shell':
                case 'code':
                    // Code cells - look for ACE editor
                    const codeEditorDiv = cell.find('.ace_editor').eq(0);
                    if (codeEditorDiv.length && codeEditorDiv.get(0).env && codeEditorDiv.get(0).env.editor) {
                        content.code = codeEditorDiv.get(0).env.editor.getValue();
                    } else {
                        // Fallback to textarea or div content
                        const codeElement = cell.find(`#content_query_${taskIndex}`);
                        if (codeElement.length) {
                            content.code = codeElement.val() || codeElement.text() || codeElement.html();
                        }
                    }
                    break;
                    
                case 'markdown':
                    let markdownElement = cell.find('.text-editor, .clarama-text-editor, .clarama-cell-content');
                    
                    if (markdownElement.length > 0) {
                        content.markdown = markdownElement.trumbowyg('html');
                    } else {
                        console.warn('Could not find markdown element at all');
                    }
                    break;
                
                case 'notification':
                    // Notification cells - extract targets and message
                    const notificationContent = cell.find('.alert, .alert-secondary');
                    const targetsElement = notificationContent.find(`.source-editor`);
                    const messageElement = notificationContent.find(`.text-editor, .clarama-text-editor`);
                    if (targetsElement.length) {
                        const targetsEditor = targetsElement.get(0);
                        content.targets = targetsEditor.env.editor.getValue();
                    }
                    
                    if (messageElement.length) {
                        content.message_content = messageElement.trumbowyg('html');
                    }
                    break;
                    
                case 'source':
                case 'task':
                    // Source/Task cells - extract source path
                    const sourceElement = cell.find('.input-group').find(`.form-control`);
                    if (sourceElement.length) {
                        content.source = sourceElement.val();
                    }
                    break;
                    
                // case 'url':
                //     // URL cells - extract mode, URL, and parameters
                //     const modeElement = cell.find(`#content_query_${taskIndex}_mode`);
                //     const urlElement = cell.find(`#content_query_${taskIndex}_url`);
                //     const paramsElement = cell.find(`#content_query_${taskIndex}_params`);
                    
                //     if (modeElement.length) {
                //         content.mode = modeElement.val();
                //     }
                //     if (urlElement.length) {
                //         content.url = urlElement.val();
                //     }
                //     if (paramsElement.length) {
                //         const paramsEditor = paramsElement.get(0);
                //         if (paramsEditor.env && paramsEditor.env.editor) {
                //             content.parameters = paramsEditor.env.editor.getValue();
                //         } else {
                //             content.parameters = paramsElement.val() || paramsElement.text();
                //         }
                //     }
                //     break;
                    
                // case 'data':
                    // Data cells - extract output and other data-specific fields
                    // const outputElement = cell.find(`#${taskIndex}_output`);
                    // if (outputElement.length) {
                    //     content.output = outputElement.val();
                    // }
                    // break;
                    
                default:
                    console.warn('Unknown cell type:', cellType);
                    // Generic fallback - try to find any content elements
                    const genericContent = cell.find(`#content_query_${taskIndex}`);
                    if (genericContent.length) {
                        content.generic = genericContent.val() || genericContent.text() || genericContent.html();
                    }
            }
            console.log('content: ', content);
            return content;
        }

        // Enhanced cell content application function
        function applyCellContent(cell, content, cellType) {
            const taskIndex = cell.attr('step');
            
            console.log('Applying content to cell type:', cellType, 'task index:', taskIndex, 'content:', content);
            
            switch(cellType) {
                case 'shell':
                case 'code':
                    if (content.code) {
                        setTimeout(() => {
                            const codeEditorDiv = cell.find('.ace_editor').eq(0);
                            if (codeEditorDiv.length && codeEditorDiv.get(0).env && codeEditorDiv.get(0).env.editor) {
                                codeEditorDiv.get(0).env.editor.setValue(content.code);
                                codeEditorDiv.get(0).env.editor.clearSelection();
                            } else {
                                // Fallback to direct element setting
                                const codeElement = cell.find(`#content_query_${taskIndex}`);
                                if (codeElement.length) {
                                    codeElement.val(content.code);
                                    codeElement.text(content.code);
                                }
                            }
                        }, 100);
                    }
                    break;
                    
                case 'markdown':
                    if (content.markdown) {
                        setTimeout(() => {
                            let markdownElement = cell.find('.text-editor, .clarama-text-editor, .clarama-cell-content');
                            
                            if (markdownElement.length) {
                                console.log('Found markdown element for applying content:', markdownElement);
                                markdownElement.val(content.markdown);
                                
                                if (typeof markdownElement.trumbowyg === 'function') {
                                    try {
                                        if (markdownElement.data('trumbowyg')) {
                                            markdownElement.trumbowyg('html', content.markdown);
                                            console.log('Successfully set Trumbowyg content');
                                        } else {
                                            console.log('Trumbowyg not initialized yet, just set textarea value');
                                        }
                                    } catch(e) {
                                        console.warn('Could not set Trumbowyg content:', e);
                                    }
                                }
                            } else {
                                console.warn('Could not find markdown element for applying content');
                            }
                        }, 100);
                    }
                    break;
                    
                case 'notification':
                    setTimeout(() => {
                        const notificationContent = cell.find('.alert, .alert-secondary');
                        const targetsElement = notificationContent.find(`.source-editor`);
                        const messageElement = notificationContent.find(`.text-editor, .clarama-text-editor`);
                        if (content.targets) {
                            if (targetsElement.length) {
                                const targetsEditor = targetsElement.get(0);
                                if (targetsEditor.env && targetsEditor.env.editor) {
                                    targetsEditor.env.editor.setValue(content.targets);
                                    targetsEditor.env.editor.clearSelection();
                                } else {
                                    targetsElement.val(content.targets);
                                }
                            }
                        }
                        
                        if (content.message_content) {
                            if (typeof messageElement.trumbowyg === 'function') {
                                try {
                                    if (messageElement.data('trumbowyg')) {
                                        messageElement.trumbowyg('html', content.message_content);
                                        console.log('Successfully set Trumbowyg content');
                                    } else {
                                        console.log('Trumbowyg not initialized yet, just set textarea value');
                                    }
                                } catch(e) {
                                    console.warn('Could not set Trumbowyg content:', e);
                                }
                            }
                        } else {
                            console.warn('Could not find markdown element for applying content');
                        }
                    }, 100);
                    break;
                    
                case 'source':
                case 'task':
                    if (content.source) {
                        setTimeout(() => {
                            const cellLeftContent = cell.find(`.left-content`);
                            const sourceElement = cellLeftContent.find('.form-control');
                            if (sourceElement.length) {
                                sourceElement.val(content.source);
                            }
                            const browseLink = cellLeftContent.find(`.text-decoration-none`);
                            if (browseLink.length) {
                                browseLink.attr('href', content.source).show();
                            }
                        }, 100);
                    }
                    break;

                    
                // case 'url':
                //     setTimeout(() => {
                //         if (content.mode) {
                //             const modeElement = cell.find(`#content_query_${taskIndex}_mode`);
                //             if (modeElement.length) {
                //                 modeElement.val(content.mode);
                //             }
                //         }
                        
                //         if (content.url) {
                //             const urlElement = cell.find(`#content_query_${taskIndex}_url`);
                //             if (urlElement.length) {
                //                 urlElement.val(content.url);
                //             }
                //         }
                        
                //         if (content.parameters) {
                //             const paramsElement = cell.find(`#content_query_${taskIndex}_params`);
                //             if (paramsElement.length) {
                //                 const paramsEditor = paramsElement.get(0);
                //                 if (paramsEditor.env && paramsEditor.env.editor) {
                //                     paramsEditor.env.editor.setValue(content.parameters);
                //                     paramsEditor.env.editor.clearSelection();
                //                 } else {
                //                     paramsElement.val(content.parameters);
                //                 }
                //             }
                //         }
                //     }, 100);
                //     break;
                    
                // case 'data':
                    // if (content.output) {
                    //     const outputElement = cell.find(`#${taskIndex}_output`);
                    //     if (outputElement.length) {
                    //         outputElement.val(content.output);
                    //         // Trigger output type setting if function exists
                    //         if (typeof datacell_setOutput === 'function') {
                    //             datacell_setOutput(taskIndex, content.output, taskIndex);
                    //         }
                    //     }
                    // }
                    // break;
                    
                default:
                    if (content.generic) {
                        const genericElement = cell.find(`#content_query_${taskIndex}`);
                        if (genericElement.length) {
                            genericElement.val(content.generic);
                        }
                    }
            }
        }

        // Context menu functions
        window.clear_cell_output = function() {
            $('#output-context-menu').hide();
            
            if (currentCellResults) {
                const cellOffset = currentCellResults.offset();
                const windowScrollTop = $(window).scrollTop();
                
                currentCellResults.empty();
                
                requestAnimationFrame(() => {
                    $(window).scrollTop(windowScrollTop);
                });
                
                currentCellResults = null; 
            }
        };
        
        window.task_cell_copy = function() {
            $('#panel-context-menu').hide();
            
            if (!currentContextCell) {
                console.warn('No cell selected for copy operation');
                return;
            }
            
            try {
                const taskIndex = currentContextCell.attr('step') || currentContextCell.attr('data-task-index');
                const stepType = currentContextCell.attr('steptype');
                const stream = currentContextCell.closest('.stream').attr('stream');
                
                // Get the JSON data for this step
                const jsonScript = $('#json_' + taskIndex);
                
                // Extract cell content using the enhanced function
                const cellContent = extractCellContent(currentContextCell);
                
                // Get loop iterable value if present
                let loopIterable = '';
                const loopInput = currentContextCell.find('.loop-iterable');
                if (loopInput.length) {
                    loopIterable = loopInput.val();
                }
                
                // Store all relevant cell data
                window.copiedCellData = {
                    stepType: stepType,
                    stream: stream,
                    taskIndex: taskIndex,
                    cellContent: cellContent,
                    loopIterable: loopIterable,
                    timestamp: new Date().getTime()
                };
                
                console.log('Copied cell data:', window.copiedCellData);
                flash('Cell copied successfully', 'success');
                
                // Visual feedback
                currentContextCell.addClass('bg-info');
                setTimeout(function() {
                    currentContextCell.removeClass('bg-info');
                }, 200);
                
            } catch (error) {
                console.error('Error copying cell:', error);
                flash('Failed to copy cell.', 'danger');
            }
        };
        
        window.task_cell_paste = function() {
            $('#panel-context-menu').hide();
            
            if (!window.copiedCellData) {
                console.warn('No cell data to paste');
                flash('No cell data to paste. Please copy a cell first.', 'danger');
                return;
            }
            
            if (!currentContextCell) {
                console.warn('No target cell selected for paste operation');
                return;
            }
            
            try {
                const targetStream = currentContextCell.closest('.stream');
                const targetStreamId = targetStream.attr('stream');
                const targetStreamFile = targetStream.attr('stream-file');
                
                new_step_id = new_step_id + 1;
                const newStepUrl = '/step/' + targetStreamId + '/' + window.copiedCellData.stepType + '/' + new_step_id + '/' + targetStreamFile + '/';
                
                // Get HTML for new step
                get_html(newStepUrl, function(new_step) {
                    const $new_element = $(new_step);
                    
                    currentContextCell.after($new_element);
                    sortUpdate(targetStream);
                    initializeNewCellDebugger($new_element);
                    
                    // Apply copied data to the new cell
                    const newTaskIndex = $new_element.attr('step');
                    
                    // Set loop iterable if present
                    if (window.copiedCellData.loopIterable) {
                        const loopInput = $new_element.find('.loop-iterable');
                        if (loopInput.length) {
                            loopInput.val(window.copiedCellData.loopIterable);
                            toggle_loop(loopInput);
                        }
                    }
                    
                    // Apply cell content
                    applyCellContent($new_element, window.copiedCellData.cellContent, window.copiedCellData.stepType);
                    
                    // Visual feedback
                    $new_element.addClass('bg-success');
                    setTimeout(function() {
                        $new_element.removeClass('bg-success');
                    }, 200);
                    
                    // Focus on the new cell
                    setTimeout(function() {
                        const newEditorDiv = $new_element.find('.ace_editor').eq(0);
                        if (newEditorDiv.length && newEditorDiv.get(0).env && newEditorDiv.get(0).env.editor) {
                            const editor = newEditorDiv.get(0).env.editor;
                            editor.focus();
                            editor.gotoLine(1, 0);
                        }
                    }, 200);
                    
                    flash('Cell pasted successfully', 'success');
                });
                
            } catch (error) {
                console.error('Error pasting cell:', error);
                flash('Failed to paste cell. Please try again.', 'danger');
            }
        };
        
        // Add keyboard shortcuts for copy/paste
        $(document).on('keydown', function(e) {
            // Check if we're in a focused cell editor
            const activeEditor = $('.ace_editor.ace_focus');
            if (activeEditor.length) {
                const cellItem = activeEditor.closest('.clarama-cell-item');
                
                // Ctrl+Shift+C for copy cell
                if (e.ctrlKey && e.shiftKey && e.keyCode === 67) {
                    e.preventDefault();
                    currentContextCell = cellItem;
                    window.task_cell_copy();
                    return false;
                }
                
                // Ctrl+Shift+V for paste cell
                if (e.ctrlKey && e.shiftKey && e.keyCode === 86) {
                    e.preventDefault();
                    currentContextCell = cellItem;
                    window.task_cell_paste();
                    return false;
                }
            }
        });
        
        console.log('Enhanced cell copy/paste functionality initialized');
    });
</script>
