<script>
    function isFolder(item) {
        return item.hasClass('bi bi-folder-fill');
    }

    // Extract the current directory depth
    var relativePath;
    function renderBreadcrumb(path, breadcrumbId, selectId, filters) {
        const targetPath = path.split('?')[0].split('/').slice(3).join('/');
        relativePath = getRelativePath("{{ file_url | path }}", targetPath);

        const breadcrumb = document.getElementById(breadcrumbId);
        breadcrumb.innerHTML = '';

        // console.log("path", path);
        const trimmedPath = path.split('/').slice(3);
        // console.log("trimmedPath", trimmedPath);

        const root = document.createElement('li');
        if (trimmedPath[0][0] != "?") {
            root.style.cursor = 'pointer';
            root.className = 'text-secondary';
            root.innerHTML = "Clarama&nbsp;>&nbsp;";
        } else {
            root.innerHTML = "Clarama";
        }
        root.addEventListener('click', () => navigateToPath(path.split('/').slice(0, 3).join('/') + "/?subfolders=True&extensions=" + filters, breadcrumbId, selectId, filters));
        breadcrumb.appendChild(root);

        trimmedPath.forEach((part, index, array) => {
            // console.log(part)
            const li = document.createElement('li');

            if (index < array.length - 1) {
            li.style.cursor = 'pointer';
            li.className = 'text-secondary';
            li.addEventListener('click', () => navigateToPath(path.split('/').slice(0, index + 4).join('/') + "?subfolders=True&extensions=" + filters, breadcrumbId, selectId, filters));
            li.innerHTML = part + "&nbsp;>&nbsp;";
            } else {
            li.innerText = part.split('?')[0];
            }
            breadcrumb.appendChild(li);
        });
    }

    function getRelativePath(from, to) {
        const fromParts = from.split('/').filter(Boolean);
        const toParts = to.split('/').filter(Boolean);
        // Find common root
        let i = 0;
        while (i < fromParts.length && i < toParts.length && fromParts[i] === toParts[i]) {
            i++;
        }

        // How many levels to go up from `from`
        const upLevels = fromParts.length - i; // eg. if this is 6-4 = 2
        const goUp = Array(upLevels).fill('..').join('/'); // this will be ../../

        // Navigate down to `to`
        const goDown = toParts.slice(i).join('/'); // extracts the remaining thats not common

        if (!goUp && !goDown) {
            return ''
        }

        return goUp ? `${goUp}/${goDown}` : goDown; // if no goUp means we r in the correct folder
    }

    function naturalSort(arr) {
        return arr.sort((a, b) => {
            return a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
        })
    }

    function renderFilesNFolder(path, breadcrumbId, selectId, filters) {
        const selectElement = document.getElementById(selectId);
        console.log(`fetch path: ${path}`)
        fetch(path)
            .then((response) => response.json())
            .then((json_files) => {
            console.log("json files", json_files)
            $(`#${selectId}`).empty();
            // const allPaths = json_files['results']['files'];
            // const foldersSet = new Set();
            // const filesSet = new Set();
            // console.log(`json_files returned: ${allPaths}`);

            // // Determine folders and files
            // allPaths.forEach(filePath => {
            //   // console.log("File path:", filePath);
            //   const parts = filePath.split('/');
            //   if (parts.length > 1) {
            //     foldersSet.add(parts[0]); // Top-level folder
            //   } else {
            //     filesSet.add(filePath); // Root-level file
            //   }
            // });

            // const sortedFolders = naturalSort([...foldersSet]);
            // const sortedFiles = naturalSort([...filesSet]);
            const sortedFolders = naturalSort(json_files['results']['folders']);
            const sortedFiles = naturalSort(json_files['results']['files']);
            console.log("folders", sortedFolders)
            console.log("files", sortedFiles)

            // using regex to filter
            // *.field.yaml -> /^.*\.field\.yaml$/
            // *.task.yaml -> /^.*\.task\.yaml$/
            // *.md -> /^.*\.md$/
            console.log("filters", filters);
            const filePathFilters = filters
                .split('|')
                .map(path => {
                const escaped = path.replace(/\./g, '\\.').replace(/\*/g,  '.*');
                return new RegExp(`${escaped}`);
                })

            console.log("filePathFilters", filePathFilters)

            // Render folders
            sortedFolders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder;
                option.className = "bi bi-folder-fill";
                option.innerHTML = `&nbsp; ${folder}`;
                if (path.split('?')[0] == "/content/json/") {
                option.addEventListener('dblclick', () => navigateToPath(`/content/json/${folder}` + "?subfolders=True&extensions=" + filters, breadcrumbId, selectId, filters));
                } else {
                option.addEventListener('dblclick', () => navigateToPath(`${path.split('?')[0]}/${folder}` + "?subfolders=True&extensions=" + filters, breadcrumbId, selectId, filters));
                }
                selectElement.appendChild(option);
            });

            // Render files with relative paths
            sortedFiles.forEach(filePath => {
                // if (!sortedFolders.has(filePath.split('/')[0])) { // ensure it's not a folder

                // only display the files that match the filters
                const matches = filePathFilters.some(regex => regex.test(filePath));
                if (!matches) return

                const option = document.createElement('option');

                // store relative path in val
                const trimmedPath = relativePath.trim();
                if (/^(?:\.\.\/)+$/.test(trimmedPath) || trimmedPath === '') {
                    option.value = trimmedPath + filePath;
                } else {
                    option.value = trimmedPath + "/" + filePath;
                }

                let matchedIcon = Object.entries(filetypeCSS)
                    .find(([ext, _]) => filePath.endsWith(ext));
                if (!matchedIcon) {
                    const simpleExt = `.${filePath.split('.').pop()}`;
                    matchedIcon = filetypeCSS[simpleExt] ? [simpleExt, filetypeCSS[simpleExt]] : null;
                }
                const icon = matchedIcon ? matchedIcon[1] : "bi-file-earmark";
                option.className = `bi ${icon}`;

                option.innerHTML = `&nbsp; ${filePath}`;
                selectElement.appendChild(option);
                // }
            });
        });
    }

    // Function to navigate to a specific path
    function navigateToPath(path, breadcrumbId, selectId, filters) {
        console.log("path", path)
        const match = path.match(/^\/content\/json\/?(.*?)(\?|$)/);
        currentModalAddContentPath = match ? match[1] : "";
        renderBreadcrumb(path, breadcrumbId, selectId, filters);
        renderFilesNFolder(path, breadcrumbId, selectId, filters);
    }

    function resolveRelativeFilePath(currentPath, relativePath) {
        const baseParts = currentPath.split('/').filter(Boolean);
        const relativeParts = relativePath.split('/').filter(Boolean);
        for (const part of relativeParts) {
            if (part === '..') {
                baseParts.pop();
            } else if (part !== '.') {
                baseParts.push(part);
            }
        }
        return baseParts.join('/');
    }
</script>